# -*- coding: utf-8 -*-
"""lb.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-KEXVYj1JAx-YVBl40fP30yAbllrAtxY
"""

#LB
import random
import math

# Biblioteca para geração de graficos para facilitar visualizão
import matplotlib.pyplot as plt

MAX_NUMERO_DE_ITERACOES_LOCAL = 5000
NUMERO_INDIVIDUOS = 10

cidades = cidades_inicial_usando_referencia()


def calcular_fitness_e_organizar_os_melhores(lista_de_solucoes):
  melhores_solucoes = []
  fitness_atual = 0
  for i in range(0, len(lista_de_solucoes)):
    fitness_atual = fitness(lista_de_solucoes[i])
    for j in range(0, len(melhores_solucoes)):
      if fitness_atual < melhores_solucoes[j][0]:
        melhores_solucoes.insert(j, [fitness_atual, i])
        break
    else:
      melhores_solucoes.append([fitness_atual, i])

  return (melhores_solucoes)

def executar_local_beam():

  # É gerada uma lista de soluções iniciais aleatoria
  solucoes = []
  for i in range(0, NUMERO_INDIVIDUOS):
    solucoes.append(gerar_solucao_aleatoria())

  # É definido um criterio de parada
  numero_de_iteracoes = MAX_NUMERO_DE_ITERACOES_LOCAL

  # --- Inicio da execução do algoritimo ---

  # Criterio de parada
  for i in range(0, numero_de_iteracoes):
    
    nova_solucao = []
    # Novas soluções são geradas
    for k in range(0, NUMERO_INDIVIDUOS):
      nova_solucao.append(mudar_solucao(solucoes[k]))
      nova_solucao.append(solucoes[k])

    # Calcula os fitness e retorna uma lista em ordem de melhor para pior
    all_fitness = calcular_fitness_e_organizar_os_melhores(nova_solucao)
    solucoes.clear()
    for k in range(0, NUMERO_INDIVIDUOS):
        solucoes.append(nova_solucao[all_fitness[k][1]])

  return fitness(solucoes[0])